#
# C++ reference documentation for the Group class.
#

#UNDOCUMENTED: [commit, get_table_typed]

ID          : class_group
TITLE       : Group
SUMMARY     : &g_group_summary
              Container for tables.
DESCR       :
- TEXT      : &g_group_descr
              >
              The Group is a container for tables. The group can be attached
              to three different forms of storage: (1) internal, (2) a user
              provided buffer or (3) a file on disk.

              When a group is attached to a buffer in memory (2), changes to tables
              in the group does not cause changes to the buffer. Regardless, the
              buffer must remain allocated as long as the group exist. A parameter
              controls whether the group assumes responsibility for deallocation or
              not.

              When a group is attached to a writable file (3), changes to tables in the group
              are kept buffered until commit() is called. The call to commit
              will update the file.

              When a group is attached to a read-only file (3), changes to tables in the group
              cannot be committed to the file, but the entire group can be serialized to
              (another) file.

              A group can be serialized into a memory buffer or a file in
              Realm's highly efficient binary format, or it can be serialized
              to a stream in either ascii or json format.

              The result of serializing in Realm's own binary format (whether as a file
              or a memory buffer) can later be attached to a group. This makes it easy
              to exchange data between applications written in any supported programming language.

              A group can hold one or more tables. If a table is going to be
              serialized, you must create the table using the group. It is not
              possible to dynamically add a table to a group.

              Accessing a Realm database file through manual
              construction of a Group object does not offer any
              level of thread safety or transaction safety. When
              any of those kinds of safety are a concern, consider
              using a SharedGroup instead. When accessing a
              database file in read/write mode through a manually
              constructed Group object, it is entirely the
              responsibility of the application that the file is
              not accessed in any way by a third party during the
              life-time of that group object. It is, on the other
              hand, safe to concurrently access a database file by
              multiple manually created Group objects, as long as
              all of them are opened in read-only mode, and there
              is no other party that modifies the file
              concurrently.

- TEXT      : Finally, A group may also be created without attached storage (4).

SEE         :
EXAMPLES    :
- DESCR     :
  CODE      : ex_cpp_group_intro
IGNORE      : []                   # List of method-ids to ignore
CATEGORIES  :
- Constructor:
  METHODS:
  - g_group_constructor_plain:
  - g_group_constructor_file:
  - g_group_constructor_memory:
  - g_group_constructor_unattached:
      NAMES    : [Group, Group, Group, Group]
      DESCR    : &g_group_constructor_descr
                 >
                 Group objects can be created in various ways
                 depending on use pattern.

                 You can either just create a new (empty) group (1), or load an
                 existing group either from a file (2) or a memory buffer (3).

                 A group may also be constructed in an unattached
                 state (4). See open() and is_attached() for more on
                 this.

      SUMMARY  : &g_group_constructor_summary
                 Creates a table group.
      ENUM_SIG:
      - SIG    : Group();
      - SIG    : Group(const std::string& file, OpenMode mode = mode_ReadOnly);
      - SIG    : Group(BinaryData buffer, bool take_ownership = true);
      - SIG    : Group(unattached_tag) noexcept;
      PARAMS:
      - NAME   : file
        TYPES  : const std::string&
        DESCR  : &g_open_filesystem_path_descr
                 Filesystem path of the Realm database file to be opened. Only ASCII characters are allowed.
      - NAME   : mode
        TYPES  : Group::OpenMode
        DESCR  : |
                 <tt>Group::mode_ReadOnly</tt>: Open in read-only mode. Fail if the file does not already exist. <br><br><tt>Group::mode_ReadWrite</tt>: Open in read/write mode. Create the file if it does not already exist. <br><br><tt>Group::mode_ReadWriteNoCreate</tt>: Open in read/write mode. Fail if the file does not already exist.
      - NAME   : buffer
        TYPES  : BinaryData
        DESCR  : &g_group_constructor_memory_parm3_descr
                 In-memory binary encoded representation of a group.
      - NAME   : take_ownership
        TYPES  : bool
        DESCR  : &g_group_take_ownership_desc
                 >
                 If <tt>take_ownership</tt> is <tt>true</tt>, you will
                 pass the ownership of the specified buffer to the
                 Group instance. In this case the buffer will
                 eventually be freed using std::free(), so the buffer
                 you pass, must have been allocated using
                 std::malloc().

                 On the other hand, if <tt>take_ownership</tt> is set
                 to <tt>false</tt>, it is your responsibility to keep
                 the memory buffer alive during the lifetime of the
                 group, and in case the buffer needs to be deallocated
                 afterwards, that is your responsibility too.

                 If an exception is signalled, the caller retains ownership
                 and must free the buffer, even if <tt>take_ownership</tt> was true.
      RETURN:
        TYPES  : Group
        DESCR  : &g_group_constructor_memory_return1_descr
                 A - possibly empty - group.
      THROWS:
      - EXCEPT : util::File::AccessError
        DESCR  : &g_group_constructor_memory_throws_descr
                 Thrown if the file (or buffer) could not be opened. If the reason
                 corresponds to one of the following exception types which are
                 derived from util::File::AccessError, the derived exception
                 type is thrown.
      - EXCEPT : util::File::PermissionDenied
        DESCR  : &g_group_exc_perm
                 Thrown if the user haven't got sufficient permissions
                 to open the database file in the desired mode.
      - EXCEPT : util::File::NotFound
        DESCR  : &g_group_exc_notfound
                 Thrown if the database file cannot be found.
      - EXCEPT : util::File::Exists
        DESCR  : &g_group_exc_exists
                 Thrown if create_Never was specified and the database file exists.
      - EXCEPT : InvalidDatabase
        DESCR  : &g_group_exc_invalid_db
                 Thrown if the specified database file does not contain a valid database.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_constructor_plain
      - DESCR  :
        CODE   : ex_cpp_group_constructor_file
      - DESCR  :
        CODE   : ex_cpp_group_constructor_memory
      - DESCR  :
        CODE   : ex_cpp_group_unattached

- Group:
  METHODS:
  - g_group_is_attached:
      NAME     : is_attached
      SUMMARY  : &g_group_is_attached_summary
                 Is this Group instance in its attached state?
      DESCR    : &g_group_is_attached_descr
                 A group may be created in the unattached state, and
                 then later attached to a file or a memory buffer with
                 a call to one of the open() methods. Calling any
                 method other than open(), is_attached(), and ~Group()
                 on an unattached instance results in undefined
                 behavior.
      CONST    : true
      RETURN:
        TYPES  : bool
        DESCR  : <code>true</code> if attached, <code>false</code> otherwise.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_is_attached

  - g_group_open_file:
  - g_group_open_memory:
      NAMES    : [open, open]
      DESCR    : >
                 Attach this Group instance to a file or an externally
                 supplied memory buffer.

                 By default, the specified file is opened in read-only
                 mode (mode_ReadOnly). This allows opening a file even
                 when the caller lacks permission to write to that
                 file. The opened group may still be modified freely,
                 but the changes cannot be written back to the same
                 file using the commit() function. An attempt to do
                 that, will cause an exception to be thrown. When
                 opening in read-only mode, it is an error if the
                 specified file does not already exist in the file
                 system.

                 Alternatively, the file can be opened in read/write
                 mode (mode_ReadWrite). This allows use of the
                 commit() function, but, of course, it also requires
                 that the caller has permission to write to the
                 specified file. When opening in read-write mode, an
                 attempt to create the specified file will be made, if
                 it does not already exist in the file system.

                 In any case, if the file already exists, it must
                 contain a valid Realm database. In many cases
                 invalidity will be detected and cause the
                 InvalidDatabase exception to be thrown, but you
                 should not rely on it.

                 A file that is passed to Group::open(), may not be
                 modified by a third party until after the Group
                 object is destroyed. Behavior is undefined if a file
                 is modified by a third party while any Group object
                 is associated with it.

                 Calling open() on a Group instance that is already in
                 the attached state has undefined behavior.

                 Specifying a memory buffer is equivalent to
                 specifying a file except that (a) in this case the
                 database is assumed to be stored in that buffer instead
                 of a file and (b) it is not possible to use commit or in
                 other ways change the buffer. If you change the contents
                 of the group and want to persist your changes you must
                 use one of the functions for serialization.

      SUMMARY  : &g_group_open_summary
                 Attach to a file or a memory buffer.
      SIGNATURE: |
                 void open(const std::string& file, OpenMode mode = mode_ReadOnly);
                 void open(BinaryData buffer, bool take_ownership = true);
      PARAMS:
      - NAME   : path
        TYPES  : const std::string&
        DESCR  : *g_open_filesystem_path_descr
      - NAME   : mode
        TYPES  : Group::OpenMode
        DESCR  : &g_group_open_memory_parm2_descr
                 Specifying mode_ReadWrite or mode_WriteNoCreate requires
                 that the specified file can be opened in read/write
                 mode. In general there is no reason to open a group
                 in read/write mode unless you want to be able to call
                 Group::commit().
      - NAME   : buffer
        TYPES  : BinaryData
        DESCR  : &g_group_open_memory_parm3_descr
                 In-memory binary encoded representation of a group.
      - NAME   : take_ownership
        TYPES  : bool
        DESCR  : *g_group_take_ownership_desc
      THROWS:
      - EXCEPT : util::File::AccessError
        DESCR  : *g_group_constructor_memory_throws_descr
      - EXCEPT : util::File::PermissionDenied
        DESCR  : *g_group_exc_perm
      - EXCEPT : util::File::NotFound
        DESCR  : *g_group_exc_notfound
      - EXCEPT : util::File::Exists
        DESCR  : *g_group_exc_exists
      - EXCEPT : InvalidDatabase
        DESCR  : *g_group_exc_invalid_db
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_open_file
      - DESCR  :
        CODE   : ex_cpp_group_open_memory

  - g_group_commit:
      NAME     : commit
      SUMMARY  : &g_group_commit_summary
                 Write changes to attached file.
      DESCR    : &g_group_commit_descr
                 >
                 Write any changes made in the group or its tables to the
                 attached file.

                 Note: This method can only be used on groups which is
                 attached to a writable file.

                 Table accessors will remain valid across the commit
                 (which is not the case for SharedGroup commits).

      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_commit

  - g_group_size:
      NAME     : size
      SUMMARY  : &g_group_table_count_summary
                 The number of tables in the group.
      DESCR    : &g_group_table_count_descr
                 >
                 A group can be a container for many tables, and this method counts
                 the number of tables currently stored in the group.
      CONST    : true
      RETURN:
        TYPES  : size_t
        DESCR  : &g_group_size_return1_descr
                 The number of tables.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_traverse

  - g_group_is_empty:
      NAME     : is_empty
      SUMMARY  : &g_group_is_empty_summary
                 Is group empty?
      DESCR    : &g_group_is_empty_descr
                 This method checks if group is empty. That is, does it have zero tables.
      CONST    : true
      RETURN:
        TYPES  : bool
        DESCR  : &g_group_is_empty_return_descr
                 <code>true</code> if group is empty, <code>false</code> otherwise.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_traverse

  - g_group_operator_equal:
      NAME     : operator==
      SUMMARY  : &g_group_operator_equal_summary
                 Compare two groups.
      DESCR    : &g_group_operator_equal_descr
                 >
                 Compare two groups for equality. Two groups are equal if
                 they contain the same tables in the same order. That
                 is, for each table T at index I in one of the groups, there is
                 a table at index I in the other group that is equal to T.
      CONST    : true
      PARAMS:
      - TYPES  : const Group&
        NAME   : g
        DESCR  : The group to compare with.
      RETURN:
        TYPES  : bool
        DESCR  : &g_group_operator_equal_return_descr
                 <code>true</code> if the two groups are equal, <code>false</code> otherwise.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_operator_equal

  - g_group_operator_not_equal:
      NAME     : operator!=
      SUMMARY  : Compare two groups.
      DESCR    : *g_group_operator_equal_descr
      CONST    : true
      PARAMS:
      - TYPES  : const Group&
        NAME   : g
        DESCR  : The group to compare with.
      RETURN:
        TYPES  : bool
        DESCR  : <code>true</code> if the two groups are not equal, <code>false</code> otherwise.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_operator_equal

- Table:
  METHODS:
  - g_group_has_table:
      NAME     : has_table
      SUMMARY  : &g_group_has_table_summary
                 Does group have table?
      DESCR:
      - TEXT   : &g_group_has_table_descr
                 The method checks if this group contains the specified table.
      - TEXT   : >
                 When no table class is specified, this function
                 returns <code>true</code> if the group contains a
                 table with the specified name.
                 When a table class (<code>MyTable</code>) is specified as a
                 template parameter, it returns true if the group contains a
                 table with the specified name, and the type of that
                 table is compatible with the specified type.
# TODO:                 See {@link concepts_table_type_compatibility} for details.
      CONST    : true
      PARAMS:
      - NAME   : name
        TYPES  : StringData
        DESCR  : &g_group_has_table_parm1_descr
                 Name of the table you wish to look for.
      RETURN:
        TYPES  : bool
        DESCR  : &g_group_has_table_return1_descr
                 <code>true</code> if the table exits, otherwise <code>false</code>.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_optional_table

  - g_group_get_table:
      NAME     : get_table
      SUMMARY  : &g_group_get_table_summary
                 Get a table.
      DESCR    : &g_group_get_table_descr
                 >
                 This method will find and return a named table.

                 When no table class is specified, this function
                 returns a dynamically typed table accessor. When a
                 table class (<code>MyTable</code>) is specified as a
                 template parameter, you get a statically typed table
                 accessor.

                 It is an error to specify unmatching table class for
                 an existing table in the group. Doing so will
                 result in undefined behaviour. For this reason you
                 should generally never call
                 <code>get_table<MyTable>()</code>
                 without first checking the type of the table with a
                 call to <code>has_table<MyTable>()</code>.

                 If no table exists with the specified name, a new
                 empty table will be created.
      SIGNATURE: |
                 TableRef          get_table(StringData name);
                 ConstTableRef     get_table(StringData name) const;
                 MyTable::Ref      get_table<MyTable>(StringData name);
                 MyTable::ConstRef get_table<MyTable>(StringData name) const;
      PARAMS:
      - NAME   : name
        TYPES  : StringData
        DESCR  : &g_group_get_table_parm1_descr
                 Name of the table you wish to retrieve.
      - NAME   : tableclass
        TYPES  : class definition
        DESCR  : &g_group_get_table_parm2_descr
                 Typed table class.
      RETURN:
        TYPES  : [TableRef, ConstTableRef]
        DESCR  : &g_group_get_table_return1_descr
                 A table reference object.
      EXAMPLES:
      -  DESCR :
         CODE  : ex_cpp_group_traverse
      -  DESCR :
         CODE  : ex_cpp_group_optional_table
      SEE      : "{@link g_group_has_table}"

  - g_group_get_table_name:
      NAME     : get_table_name
      DESCR    : &g_group_get_table_name_descr
                 This method will find the name of a table stored in the group.
      SUMMARY  : &g_group_get_table_name_summary
                 Get the name of a table.
      CONST    : true
      PARAMS:
      - NAME   : table_index
        TYPES  : size_t
        DESCR  : &g_group_get_table_name_parm1_descr
                 Table index.
      RETURN:
        TYPES  : StringData
        DESCR  : &g_group_get_table_name_return1_descr
                 The table name.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_traverse

- Serialization:
  METHODS:
  - g_group_write_to_stream:
      NAME     : write
      SUMMARY  : &g_group_write_to_stream_summary
                 Write this database to the specified output stream.
      CONST    : true
      PARAMS:
      - NAME   : out
        TYPES  : std::ostream&
        DESCR  : &g_group_write_to_stream_parm1_descr
                 The tareget stream.

  - g_group_write_to_file:
      NAME     : write
      SUMMARY  : &g_group_write_to_file_summary
                 Write this group of tables to a new file.
      DESCR    : &g_group_write_to_file_descr
                 This method will write the group to persistent storage (disk). Metadata and tables
                 will be stored, and can be retrieved at later times.

                 It is an error to specify a file that already exists.
                 This is to protect against overwriting a database file
                 that is currently open, which would cause undefined
                 behaviour.
      CONST    : true
      PARAMS:
      - NAME   : path
        TYPES  : const std::string&
        DESCR  : &g_group_write_to_file_parm1_descr
                 A filesystem path to write to.
      THROWS:
      - EXCEPT : util::File::AccessError
        DESCR  : &g_group_write_to_file_throws_descr
                 Thrown if the file could not be opened. If the reason
                 corresponds to one of the exception types that are
                 derived from util::File::AccessError, the derived exception
                 type is thrown. In particular, util::File::Exists will be
                 thrown if the file exists already.
      - EXCEPT : util::File::PermissionDenied
        DESCR  : *g_group_exc_perm
      - EXCEPT : util::File::Exists
        DESCR  : *g_group_exc_exists
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_open_file

  - g_group_write_to_mem:
      NAME     : write_to_mem
      SUMMARY  : &g_group_write_to_mem_summary
                 Write a group to an in-memory buffer.
      DESCR    :
      - TEXT   : &g_group_write_to_mem_descr
                 This method will write the group to an in-memory buffer. This may be useful if you
                 want to transfer a group over a network connection.
      - TEXT   : The returned buffer will have been
                 allocated using std::malloc(). The ownership of the buffer is passed to the caller.
      CONST    : true
      RETURN:
        DESCR  : The allocated buffer. You will have to call std::free() when you are done with it.
        TYPES  : BinaryData
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_write_to_mem

  - g_group_tostring:
      NAME     : to_string
      SUMMARY  : &g_group_to_string_summary
                 Get a string representation of the group.
      DESCR:
      - TEXT   : &g_group_to_string_descr
                 This method provides a string representation of the group.
      - TEXT   : The string representation is added to an output stream.
      CONST    : true
      PARAMS:
      - NAME   : out
        TYPES  : std::ostream&
        DESCR  : &g_group_tostring_parm1_descr
                 The output stream.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_tostring

  - g_group_to_json:
      NAME     : to_json
      SUMMARY  : &g_group_to_json_summary
                 Get a JSON representation of the group.
      SIGNATURE: template<class S> void to_json(S& out) const
      DESCR    :
      - TEXT   : &g_group_to_json_descr
                 This methods provides a JSON representation of the group.
                 The group is represented as an JSON object where the tables are
                 elements/attributes.
      - TEXT   : The JSON representation is added to an output stream.
      CONST    : true
      PARAMS:
      - NAME   : out
        TYPES  : S&
        DESCR  : Stream template class to use for outputting the result.
      EXAMPLES:
      - DESCR  :
        CODE   : ex_cpp_group_to_json
